#!/usr/bin/env python3
"""Overlay plot of fused GNSS+IMU estimate versus ground truth for Task 6.

Usage:
    python task6_overlay_plot.py --est-file <fused_estimate.npz> \
        --truth-file <STATE_X001.txt> --method TRIAD --frame ECEF \
        --dataset IMU_X002_GNSS_X002 [--all-frames] [--show] [--debug]

This script synchronizes the time bases of the estimator output and ground
truth, then generates overlay figures (NED/ECEF/BODY) with the fused estimate
and TRUTH data. This replaces the GNSS series from Task 5 with TRUTH for
Task 6 overlays. Figures are written under ``results/`` using both patterns:

- ``<run_id>_task6_overlay_state_<frame>.{pdf,png}"
- ``<run_id>_task6_all_<frame>.{pdf,png}" (mirrors Task 5 naming)

Use ``--all-frames`` to generate NED, ECEF and BODY overlays, and ``--show``
to display figures in addition to saving. With ``--debug`` the script prints
diagnostics about the input datasets. By default, figures are saved under
``PYTHON/results`` so they appear alongside Task 5 outputs generated by the
Python pipeline.
"""

from __future__ import annotations

import argparse
from pathlib import Path

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import warnings
from typing import Optional

try:
    from scipy.spatial.transform import Rotation as R  # optional for BODY
except Exception:  # pragma: no cover
    R = None  # type: ignore


# ---------------------------------------------------------------------------
# helper functions
# ---------------------------------------------------------------------------


def load_truth(path: Path, frame: str) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Load ground truth file ``STATE_X*.txt``.

    Parameters
    ----------
    path : Path
        Path to the truth file (txt or npz).
    frame : {"ECEF", "NED"}
        Frame for the output arrays.

    Returns
    -------
    time : ndarray of shape (N,)
    pos : ndarray of shape (N, 3)
    vel : ndarray of shape (N, 3)
    acc : ndarray of shape (N, 3)
    """
    if path.suffix == ".npz":
        data = np.load(path)
        if frame == "ECEF":
            pos = data["pos_ecef_m"]
            vel = data["vel_ecef_ms"]
        else:
            pos = data["pos_ned_m"]
            vel = data["vel_ned_ms"]
        time = data["time_s"]
    else:
        raw = np.loadtxt(path)
        time = raw[:, 1]
        if frame == "ECEF":
            pos = raw[:, 2:5]
            vel = raw[:, 5:8]
        else:
            pos = raw[:, 9:12]
            vel = raw[:, 12:15]
    acc = np.gradient(np.gradient(pos, axis=0), axis=0) / np.diff(time).mean() ** 2
    return time, pos, vel, acc


def load_estimate(
    path: Path, frame: str
) -> Optional[tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, Optional[np.ndarray]]]:
    """Load fused estimate ``.npz`` file.

    Returns (time, pos, vel, acc, att_quat) or ``None`` if mandatory keys
    are missing. ``att_quat`` may be ``None`` if not present in the file.
    """
    data = np.load(path)
    required = ["time_s"]
    if frame == "ECEF":
        required += ["pos_ecef_m", "vel_ecef_ms"]
    elif frame == "NED":
        required += ["pos_ned_m", "vel_ned_ms"]
    elif frame == "BODY":
        # Prefer direct body keys if available; otherwise we'll try to derive
        # BODY from NED later using attitude.
        if "pos_body_m" in data and "vel_body_ms" in data:
            required += ["pos_body_m", "vel_body_ms"]
    missing = [k for k in required if k not in data]
    if missing:
        warnings.warn(
            f"{', '.join(missing)} missing in {path.name}; skipping overlay",
            RuntimeWarning,
        )
        return None

    time = data["time_s"]
    if frame == "ECEF":
        pos = data["pos_ecef_m"]
        vel = data["vel_ecef_ms"]
    elif frame == "NED":
        pos = data["pos_ned_m"]
        vel = data["vel_ned_ms"]
    elif frame == "BODY":
        if "pos_body_m" in data and "vel_body_ms" in data:
            pos = data["pos_body_m"]
            vel = data["vel_body_ms"]
        else:
            # temporary placeholders; caller may replace after rotation
            pos = data.get("pos_ned_m", np.zeros((len(time), 3)))
            vel = data.get("vel_ned_ms", np.zeros((len(time), 3)))
    if "acc_ecef_ms2" in data and frame == "ECEF":
        acc = data["acc_ecef_ms2"]
    elif "acc_ned_ms2" in data and frame in ("NED", "BODY"):
        acc = data["acc_ned_ms2"]
    else:
        acc = np.gradient(np.gradient(pos, axis=0), axis=0) / np.diff(time).mean() ** 2
    att_quat = data.get("att_quat", None)
    return time, pos, vel, acc, att_quat


def interpolate_truth(t_est: np.ndarray, t_truth: np.ndarray, arr: np.ndarray) -> np.ndarray:
    """Interpolate ``arr`` to estimator time vector."""
    f = interp1d(t_truth, arr, axis=0, bounds_error=False, fill_value="extrapolate")
    return f(t_est)


def print_debug_info(
    t_est: np.ndarray, vel_est: np.ndarray, t_truth: np.ndarray, vel_truth: np.ndarray
) -> None:
    """Print dataset statistics to aid alignment debugging."""
    print(f"Length of fused velocity: {vel_est.shape}")
    print(f"Length of truth velocity: {vel_truth.shape}")
    print(f"Fused time range: {t_est[0]:.3f} to {t_est[-1]:.3f}")
    print(f"Truth time range: {t_truth[0]:.3f} to {t_truth[-1]:.3f}")
    print("First 5 fused velocity X:", vel_est[:5, 0])
    print("First 5 truth velocity X:", vel_truth[:5, 0])
    print("Last 5 fused velocity X:", vel_est[-5:, 0])
    print("Last 5 truth velocity X:", vel_truth[-5:, 0])
    dv_truth = np.diff(vel_truth[:, 0])
    dv_est = np.diff(vel_est[:, 0])
    print("Max velocity jump in truth (X):", np.max(np.abs(dv_truth)))
    print("Max velocity jump in fused (X):", np.max(np.abs(dv_est)))


def maybe_to_body(
    pos_ned: np.ndarray,
    vel_ned: np.ndarray,
    att_quat: Optional[np.ndarray],
) -> tuple[Optional[np.ndarray], Optional[np.ndarray]]:
    """Rotate NED vectors to BODY using attitude quaternions if available.

    Assumes quaternions encode BODY->NED. Returns (None, None) if attitude
    or SciPy Rotation is unavailable.
    """
    if att_quat is None or R is None:
        return None, None
    try:
        rot = R.from_quat(att_quat)
        C_b2n = rot.as_matrix()  # (N,3,3)
        C_n2b = np.transpose(C_b2n, (0, 2, 1))
        p_body = np.einsum("nij,nj->ni", C_n2b, pos_ned)
        v_body = np.einsum("nij,nj->ni", C_n2b, vel_ned)
        return p_body, v_body
    except Exception:
        return None, None


# ---------------------------------------------------------------------------
# length handling
# ---------------------------------------------------------------------------


def ensure_equal_length(
    t_est: np.ndarray,
    pos_est: np.ndarray,
    vel_est: np.ndarray,
    acc_est: np.ndarray,
    pos_truth_i: np.ndarray,
    vel_truth_i: np.ndarray,
    acc_truth_i: np.ndarray,
) -> tuple[
    np.ndarray,
    np.ndarray,
    np.ndarray,
    np.ndarray,
    np.ndarray,
    np.ndarray,
    np.ndarray,
]:
    """Truncate arrays to the common minimum length."""
    if len(pos_est) != len(pos_truth_i):
        n = min(len(pos_est), len(pos_truth_i))
        warnings.warn(
            f"Length mismatch after interpolation (est {len(pos_est)}, truth {len(pos_truth_i)}); truncating to {n}",
            RuntimeWarning,
        )
        t_est = t_est[:n]
        pos_est = pos_est[:n]
        vel_est = vel_est[:n]
        acc_est = acc_est[:n]
        pos_truth_i = pos_truth_i[:n]
        vel_truth_i = vel_truth_i[:n]
        acc_truth_i = acc_truth_i[:n]
    assert len(pos_est) == len(pos_truth_i)
    return (
        t_est,
        pos_est,
        vel_est,
        acc_est,
        pos_truth_i,
        vel_truth_i,
        acc_truth_i,
    )


# ---------------------------------------------------------------------------
# plotting
# ---------------------------------------------------------------------------


def plot_overlay(
    t_est: np.ndarray,
    pos_est: np.ndarray,
    vel_est: np.ndarray,
    acc_est: np.ndarray,
    t_truth: np.ndarray,
    pos_truth: np.ndarray,
    vel_truth: np.ndarray,
    acc_truth: np.ndarray,
    frame: str,
    method: str,
    dataset: str,
    out_dir: Path,
    show: bool = False,
    also_task6_all_name: bool = True,
) -> Path:
    """Create the overlay plot and save it to ``out_dir``.

    The figure uses a consistent legend scheme: the fused estimate is shown
    in a red solid line with ``"x"`` markers, and the ground truth is shown
    in a black dotted line with ``"*"`` markers.
    """
    labels = ["X", "Y", "Z"] if frame == "ECEF" else ["N", "E", "D"]

    fig, axes = plt.subplots(2, 3, figsize=(12, 6), sharex=True)

    datasets = [
        (pos_est, pos_truth, "Position [m]"),
        (vel_est, vel_truth, "Velocity [m/s]"),
    ]

    for row, (est, truth, ylab) in enumerate(datasets):
        for col in range(3):
            ax = axes[row, col]
            # plot fused estimate in red with 'x' marker
            label_fused = "Fused" if (row == 0 and col == 0) else "_nolegend_"
            ax.plot(
                t_est,
                est[:, col],
                "r-",
                linewidth=2,
                marker="x",
                markersize=3,
                label=label_fused,
            )
            # plot truth in black dotted with '*' marker
            label_truth = "Truth" if (row == 0 and col == 0) else "_nolegend_"
            ax.plot(
                t_est,
                truth[:, col],
                "k:",
                marker="*",
                markersize=3,
                label=label_truth,
            )
            ax.set_ylabel(ylab if col == 0 else "")
            ax.grid(True, alpha=0.3)
            if row == 0:
                ax.set_title(labels[col])
            ax.set_xlabel("Time [s]")

    axes[0, 0].legend(loc="upper right", fontsize=9, frameon=True)

    fig.suptitle(f"{dataset} Task 6 Overlay — {method} ({frame} frame)")
    fig.tight_layout(rect=[0, 0, 1, 0.95])
    run_id = f"{dataset}_{method}"
    out_dir.mkdir(parents=True, exist_ok=True)
    pdf_path = out_dir / f"{run_id}_task6_overlay_state_{frame}.pdf"
    png_path = out_dir / f"{run_id}_task6_overlay_state_{frame}.png"
    fig.savefig(pdf_path)
    fig.savefig(png_path)
    if also_task6_all_name:
        fig.savefig(out_dir / f"{run_id}_task6_all_{frame}.pdf")
        fig.savefig(out_dir / f"{run_id}_task6_all_{frame}.png")
    if show:
        plt.show()
    plt.close(fig)
    print(f"Saved overlay figure to {pdf_path}")
    return pdf_path


def plot_rmse(
    t: np.ndarray,
    pos_est: np.ndarray,
    vel_est: np.ndarray,
    acc_est: np.ndarray,
    pos_truth: np.ndarray,
    vel_truth: np.ndarray,
    acc_truth: np.ndarray,
    frame: str,
    method: str,
    dataset: str,
    out_dir: Path,
    show: bool = False,
) -> Path:
    """Plot total error magnitude and annotate RMSE values."""
    pos_err = np.linalg.norm(pos_est - pos_truth, axis=1)
    vel_err = np.linalg.norm(vel_est - vel_truth, axis=1)
    acc_err = np.linalg.norm(acc_est - acc_truth, axis=1)

    rmse_pos = float(np.sqrt(np.mean(pos_err**2)))
    rmse_vel = float(np.sqrt(np.mean(vel_err**2)))
    rmse_acc = float(np.sqrt(np.mean(acc_err**2)))

    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(t, pos_err, label=f"Pos RMSE {rmse_pos:.3f} m")
    ax.plot(t, vel_err, label=f"Vel RMSE {rmse_vel:.3f} m/s")
    ax.plot(t, acc_err, label=f"Acc RMSE {rmse_acc:.3f} m/s$^2$")
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Error magnitude")
    ax.grid(True, alpha=0.3)
    ax.legend()
    ax.set_title(f"{dataset} Task 6 RMSE — {method} ({frame} frame)")
    fig.tight_layout()

    run_id = f"{dataset}_{method}"
    run_dir = out_dir / run_id
    run_dir.mkdir(parents=True, exist_ok=True)
    pdf_path = run_dir / f"{run_id}_Task6_{frame}_RMSE.pdf"
    png_path = run_dir / f"{run_id}_Task6_{frame}_RMSE.png"
    fig.savefig(pdf_path)
    fig.savefig(png_path)
    if show:
        plt.show()
    plt.close(fig)
    print(f"Saved RMSE figure to {pdf_path}")
    return pdf_path


# ---------------------------------------------------------------------------
# main entry point
# ---------------------------------------------------------------------------


def main() -> None:
    ap = argparse.ArgumentParser(
        description="Generate Task 6 overlay plot of fused estimate vs truth"
    )
    ap.add_argument("--est-file", required=True, help="fused estimator .npz file")
    ap.add_argument("--truth-file", required=True, help="ground truth STATE_X file")
    ap.add_argument("--method", required=True, help="estimation method name")
    ap.add_argument("--frame", choices=["ECEF", "NED", "BODY"], default="ECEF", help="reference frame")
    ap.add_argument("--all-frames", action="store_true", help="generate NED, ECEF and BODY overlays")
    ap.add_argument("--dataset", required=True, help="dataset identifier for filename")
    ap.add_argument(
        "--output-dir",
        default="PYTHON/results",
        help="directory for saved figure (default: PYTHON/results)",
    )
    ap.add_argument("--debug", action="store_true", help="print dataset diagnostics")
    ap.add_argument("--show", action="store_true", help="display figures in addition to saving")
    args = ap.parse_args()

    est_path = Path(args.est_file)
    truth_path = Path(args.truth_file)
    out_dir = Path(args.output_dir)

    def process_one(frame: str) -> None:
        est = load_estimate(est_path, frame)
        if est is None:
            print(f"Missing data in {est_path.name} for {frame}; overlay skipped.")
            return
        t_est, pos_est, vel_est, acc_est, att_quat = est

        if frame == "BODY":
            # Load truth in NED, interpolate to estimator time, then rotate to BODY
            t_truth_ned, pos_truth_ned, vel_truth_ned, acc_truth_ned = load_truth(truth_path, "NED")
            pos_truth_i_ned = interpolate_truth(t_est, t_truth_ned, pos_truth_ned)
            vel_truth_i_ned = interpolate_truth(t_est, t_truth_ned, vel_truth_ned)
            acc_truth_i = interpolate_truth(t_est, t_truth_ned, acc_truth_ned)

            # If BODY not directly available from estimate, derive from NED using attitude
            if (pos_est.shape != pos_truth_i_ned.shape) or (vel_est.shape != vel_truth_i_ned.shape):
                est_ned = load_estimate(est_path, "NED")
                if est_ned is not None:
                    _, pos_ned_e, vel_ned_e, _, att_q = est_ned
                    p_body_e, v_body_e = maybe_to_body(pos_ned_e, vel_ned_e, att_q)
                    if p_body_e is not None and v_body_e is not None:
                        pos_est, vel_est = p_body_e, v_body_e

            p_truth_b, v_truth_b = maybe_to_body(pos_truth_i_ned, vel_truth_i_ned, att_quat)
            if p_truth_b is None or v_truth_b is None:
                warnings.warn("BODY overlay skipped: attitude not available to rotate truth.")
                return
            pos_truth_i, vel_truth_i = p_truth_b, v_truth_b
        else:
            t_truth, pos_truth, vel_truth, acc_truth = load_truth(truth_path, frame)
            pos_truth_i = interpolate_truth(t_est, t_truth, pos_truth)
            vel_truth_i = interpolate_truth(t_est, t_truth, vel_truth)
            acc_truth_i = interpolate_truth(t_est, t_truth, acc_truth)

        if args.debug:
            if frame != "BODY":
                print_debug_info(t_est, vel_est, t_truth, vel_truth)  # type: ignore[arg-type]
            else:
                print(f"BODY frame: est_len={len(t_est)}; truth rotated to BODY.")

        (
            t_c,
            pos_est_c,
            vel_est_c,
            acc_est_c,
            pos_truth_c,
            vel_truth_c,
            acc_truth_c,
        ) = ensure_equal_length(
            t_est,
            pos_est,
            vel_est,
            acc_est,
            pos_truth_i,
            vel_truth_i,
            acc_truth_i,
        )

        plot_overlay(
            t_c,
            pos_est_c,
            vel_est_c,
            acc_est_c,
            t_c,
            pos_truth_c,
            vel_truth_c,
            acc_truth_c,
            frame,
            args.method,
            args.dataset,
            out_dir,
            show=args.show,
            also_task6_all_name=True,
        )

        plot_rmse(
            t_c,
            pos_est_c,
            vel_est_c,
            acc_est_c,
            pos_truth_c,
            vel_truth_c,
            acc_truth_c,
            frame,
            args.method,
            args.dataset,
            out_dir,
            show=args.show,
        )

    if args.all_frames:
        for f in ("NED", "ECEF", "BODY"):
            process_one(f)
    else:
        process_one(args.frame)

    run_id = f"{args.dataset}_{args.method}"
    saved = sorted(out_dir.glob(f"{run_id}_task6_*.pdf"))
    if saved:
        print("Saved files under", out_dir.resolve())
        for f in saved:
            print(" -", f.name)


if __name__ == "__main__":
    main()
