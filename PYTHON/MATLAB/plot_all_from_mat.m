function plot_all_from_mat(mat_path, save_dir)
% plot_all_from_mat Load a saved *_kf_output.mat file and reproduce plots.
%
% You said you'll run from: /Users/vimalchawda/Desktop/IMU/PYTHON/MATLAB
% This helper auto-resolves results from the sibling ../results folder.
%
% Easiest (no arguments): picks the newest *_kf_output.mat under ../results
%   plot_all_from_mat
%
% Or pass a dataset tag or filename (path optional):
%   plot_all_from_mat('IMU_X002_GNSS_X002_TRIAD_kf_output.mat')
%   plot_all_from_mat('IMU_X002_GNSS_X002_TRIAD')
%
% Also save .fig/.png into MATLAB/results:
%   plot_all_from_mat('IMU_X002_GNSS_X002_TRIAD', 'results')
%
% The MAT file is produced by the Python pipeline and contains time-aligned
% fused states, GNSS (raw and interpolated), residuals, innovations, and
% attitude. This script renders a compact set of figures similar to Python.
%
% Expected plots (when data available):
% - Task 1 summary: g_NED, omega_ie_NED (from <tag>_tasks.mat)
% - Task 2 summary: g_body, omega_ie_body (from <tag>_tasks.mat)
% - Task 3 summary: mean gravity/earth-rate errors (from <tag>_tasks.mat)
% - Task 4: NED states — Position/Velocity/Acceleration overlays (fused vs GNSS)
% - Task 5: Innovations (pre-fit) and Residuals (if present in MAT)
% - Task 6: Truth vs Fused overlays (if truth present)
% - Attitude over time (deg)
% - Optional: ECEF position overlay (if present)
%
% Not included here (Python-only or separate scripts):
% - Mixed-frame comparisons, body-frame all-panels, method-by-method grids
% - Full Task 7 truth vs estimate breakdowns (generated by Python scripts)

if nargin < 2, save_dir = ''; end
thisdir = fileparts(mfilename('fullpath'));
py_results = fullfile(thisdir, '..', 'results');

% Auto-pick latest results when no file provided
if nargin < 1 || isempty(mat_path)
    d = dir(fullfile(py_results, '*_kf_output.mat'));
    if isempty(d)
        error('No *_kf_output.mat found under %s', py_results);
    end
    [~, idx] = max([d.datenum]);
    mat_path = fullfile(d(idx).folder, d(idx).name);
end

% If a bare tag was given (e.g., 'IMU_X002_GNSS_X002_TRIAD'), expand to path
if ~contains(mat_path, filesep) && ~endsWith(mat_path, '.mat')
    mat_path = fullfile(py_results, [mat_path '_kf_output.mat']);
end

% If still not found, try in ../results, else throw
if exist(mat_path, 'file') ~= 2
    cand = fullfile(py_results, mat_path);
    if exist(cand, 'file') == 2
        mat_path = cand;
    else
        error('MAT file not found: %s (also tried %s)', mat_path, cand);
    end
end

S = load(mat_path);
report = {};
add = @(name, ok, why) assignin('caller','report', [report; {name, ok, why}]); %#ok<NASGU>

% Unwrap if data is nested under a single field (common with some exporters)
max_unwrap = 3;
for i = 1:max_unwrap
    fns = fieldnames(S);
    if numel(fns) == 1 && isstruct(S.(fns{1}))
        S = S.(fns{1});
    else
        break
    end
end

% Resolve time vectors (robust fallback if fields missing)
if isfield(S, 't')
    t = S.t(:);
elseif isfield(S, 'time')
    t = S.time(:);
elseif isfield(S, 'time_s')
    t = S.time_s(:);
elseif isfield(S, 't_est')
    t = S.t_est(:);
elseif isfield(S, 't_rel_imu')
    t = S.t_rel_imu(:);
else
    % Infer from available arrays
    t = [];
    cand = {'pos_ned','pos_ned_m','fused_pos','vel_ned','vel_ned_ms','fused_vel','euler_deg','att_quat','quat_log'};
    for c = 1:numel(cand)
        if isfield(S, cand{c}) && ~isempty(S.(cand{c}))
            N = size(S.(cand{c}),1);
            if isfield(S,'dt') && ~isempty(S.dt)
                dtv = S.dt(1);
                t = (0:N-1)' * dtv;
            elseif isfield(S,'imu_rate_hz') && ~isempty(S.imu_rate_hz)
                dtv = 1./double(S.imu_rate_hz(1));
                t = (0:N-1)' * dtv;
            else
                t = (0:N-1)';
            end
            break;
        end
    end
    if isempty(t)
        fn_list = strjoin(fieldnames(S)', ', ');
        error('Could not infer IMU time vector: missing t/time and data fields. Available fields: %s', fn_list);
    end
end

if isfield(S, 't_rel_imu')
    t_rel = S.t_rel_imu(:);
else
    t_rel = t - t(1);
end

tg = []; tg_shift = [];
if isfield(S, 't_gnss'),         tg = S.t_gnss(:); end
if isempty(tg) && isfield(S, 'gnss_pos_ned') && ~isempty(S.gnss_pos_ned)
    tg = (0:size(S.gnss_pos_ned,1)-1)';
end
if isfield(S, 't_gnss_shifted'), tg_shift = S.t_gnss_shifted(:); end

% Convenience fetcher (safe default)
getf = @(name,def) local_getf(S, name, def);

% Try to infer run tag and locate per-task bundle
[tag, basefile] = local_tag_from_path(mat_path, S);
tasks_mat = strrep(mat_path, '_kf_output.mat', '_tasks.mat');
if exist(tasks_mat, 'file') ~= 2
    % Also try sibling ../results/<tag>_tasks.mat
    thisdir = fileparts(mfilename('fullpath'));
    py_results = fullfile(thisdir, '..', 'results');
    alt = fullfile(py_results, [tag '_tasks.mat']);
    if exist(alt, 'file') == 2
        tasks_mat = alt;
    else
        tasks_mat = '';
    end
end

% Optional Task 1/2/3 summary (if tasks.mat available)
if ~isempty(tasks_mat)
    try
        T = load(tasks_mat);
        if isfield(T,'task1')
            figure('Name','Task 1 — Reference Vectors','Color','w');
            subplot(1,2,1); bar(T.task1.g_ned); grid on; title('g_NED'); xticklabels({'N','E','D'});
            subplot(1,2,2); bar(T.task1.omega_ie_ned); grid on; title('\omega_{ie} (NED)'); xticklabels({'N','E','D'});
        end
        if isfield(T,'task2')
            figure('Name','Task 2 — Body Vectors','Color','w');
            subplot(1,2,1); bar(T.task2.g_body); grid on; title('g_{body}'); xticklabels({'X','Y','Z'});
            subplot(1,2,2); bar(T.task2.omega_ie_body); grid on; title('\omega_{ie}^{body}'); xticklabels({'X','Y','Z'});
        end
        if isfield(T,'task3')
            figure('Name','Task 3 — Attitude Error Summary','Color','w');
            vals = [T.task3.grav_err_deg(1), T.task3.earth_rate_err_deg(1)];
            bar(vals); set(gca,'XTickLabel',{'Gravity','Earth-rate'}); grid on;
            ylabel('deg'); title('Mean errors');
        end
    catch ME
        warning('Failed to load per-task bundle: %s', ME.message);
    end
end

% Core series (NED) with flexible field names
pos  = []; vel = [];
if isfield(S,'pos_ned') && ~isempty(S.pos_ned), pos = S.pos_ned; end
if isempty(pos) && isfield(S,'pos_ned_m') && ~isempty(S.pos_ned_m), pos = S.pos_ned_m; end
if isempty(pos) && isfield(S,'fused_pos') && ~isempty(S.fused_pos), pos = S.fused_pos; end
if isfield(S,'vel_ned') && ~isempty(S.vel_ned), vel = S.vel_ned; end
if isempty(vel) && isfield(S,'vel_ned_ms') && ~isempty(S.vel_ned_ms), vel = S.vel_ned_ms; end
if isempty(vel) && isfield(S,'fused_vel') && ~isempty(S.fused_vel), vel = S.fused_vel; end

gpos = getf('gnss_pos_ned', []); gvel = getf('gnss_vel_ned', []);
gpos_i = getf('gnss_pos_ned_interp', []); gvel_i = getf('gnss_vel_ned_interp', []);
gacc_i = getf('gnss_acc_ned_interp', []);

% If GNSS overlays are missing, derive them from the GNSS CSV
if (isempty(gpos) || isempty(gvel) || isempty(gpos_i) || isempty(gvel_i))
    try
        [tg2, gpos, gvel, gpos_i, gvel_i, gacc_i] = local_load_gnss_derived(tag, t, S);
        tg = tg2;  % adopt derived GNSS time base for raw overlays
    catch ME
        warning('GNSS overlays unavailable and could not derive from CSV: %s', ME.message);
    end
end

% Residuals / Innovations
innov_pos = getf('innov_pos', []); innov_vel = getf('innov_vel', []);
res_pos   = getf('residual_pos', []); res_vel = getf('residual_vel', []);
time_res  = getf('time_residuals', []);

% Attitude
eul_deg = getf('euler_deg', []);
if isempty(eul_deg)
    % Try to compute from quaternion logs
    Q = [];
    if isfield(S,'attitude_q') && ~isempty(S.attitude_q), Q = S.attitude_q; end
    if isempty(Q) && isfield(S,'att_quat') && ~isempty(S.att_quat), Q = S.att_quat; end
    if isempty(Q) && isfield(S,'quat_log') && ~isempty(S.quat_log), Q = S.quat_log; end
    if ~isempty(Q)
        eul_deg = local_quat_to_euler_deg(Q);
    end
end

% Task 4: Position/Velocity/Acceleration (NED)
labels = {'North','East','Down'};
if isempty(pos)
    warning('NED position/velocity not found; skipping NED States figure');
else
    figure('Name','Task 4 — NED States','Color','w');
    for i=1:3
        subplot(3,3,i);
        hold on; grid on; title(['Position ' labels{i}]);
        if ~isempty(gpos_i), plot(t, gpos_i(:,i), 'k-', 'DisplayName','GNSS (interp)'); end
        if ~isempty(gpos),   plot(tg, gpos(:,i),  'k:', 'DisplayName','GNSS (raw)');    end
        if ~isempty(pos),    plot(t, pos(:,i),    'b-', 'DisplayName','Fused');         end
        legend('show'); xlabel('Time [s]'); ylabel('m');
        subplot(3,3,3+i);
        hold on; grid on; title(['Velocity ' labels{i}]);
        if ~isempty(gvel_i), plot(t, gvel_i(:,i), 'k-', 'DisplayName','GNSS (interp)'); end
        if ~isempty(gvel),   plot(tg, gvel(:,i),  'k:', 'DisplayName','GNSS (raw)');     end
        if ~isempty(vel),    plot(t, vel(:,i),    'b-', 'DisplayName','Fused');          end
        legend('show'); xlabel('Time [s]'); ylabel('m/s');
        subplot(3,3,6+i);
        hold on; grid on; title(['Acceleration ' labels{i}]);
        if ~isempty(gacc_i), plot(t, gacc_i(:,i), 'k-', 'DisplayName','GNSS (interp)'); end
        if isfield(S,'fused_acc') && ~isempty(S.fused_acc), plot(t, S.fused_acc(:,i), 'b-', 'DisplayName','Fused'); end
        legend('show'); xlabel('Time [s]'); ylabel('m/s^2');
    end
end

% Task 5: Innovations (or pseudo-innovations from GNSS interp if KF logs missing)
if ~isempty(innov_pos)
    figure('Name','Task 5 — Innovations','Color','w');
    for i=1:3
        subplot(3,1,i); hold on; grid on; title([labels{i} ' innovations']);
        plot(innov_pos(:,i), 'b-', 'DisplayName','Position');
        if ~isempty(innov_vel), plot(innov_vel(:,i), 'r--', 'DisplayName','Velocity'); end
        legend('show'); xlabel('GNSS update index'); ylabel('Residual');
    end
elseif ~isempty(gpos_i) && ~isempty(pos)
    % Approximate innovations as (GNSS_interp - Fused), for visualization only
    try
        innov_est = gpos_i - pos;
        figure('Name','Task 5 — Innovations (approx)','Color','w');
        for i=1:3
            subplot(3,1,i); hold on; grid on; title([labels{i} ' pseudo-innov']);
            plot(innov_est(:,i), 'b-', 'DisplayName','Position (approx)');
            legend('show'); xlabel('Sample index'); ylabel('Residual');
        end
    catch
        % ignore
    end
end

% Task 5: Residuals vs time (or compute from GNSS if missing)
if ~isempty(res_pos) && ~isempty(time_res)
    figure('Name','Task 5 — Residuals','Color','w');
    for i=1:3
        subplot(3,1,i); hold on; grid on; title([labels{i} ' residuals']);
        plot(time_res, res_pos(:,i), 'b-', 'DisplayName','Position');
        if ~isempty(res_vel), plot(time_res, res_vel(:,i), 'r--', 'DisplayName','Velocity'); end
        legend('show'); xlabel('Time [s]');
    end
elseif ~isempty(gpos_i) && ~isempty(pos)
    try
        res_pos = pos - gpos_i;
        if ~isempty(gvel_i) && ~isempty(vel)
            res_vel = vel - gvel_i;
        else
            res_vel = [];
        end
        time_res = t;
        figure('Name','Task 5 — Residuals (GNSS-based)','Color','w');
        for i=1:3
            subplot(3,1,i); hold on; grid on; title([labels{i} ' residuals']);
            plot(time_res, res_pos(:,i), 'b-', 'DisplayName','Position');
            if ~isempty(res_vel), plot(time_res, res_vel(:,i), 'r--', 'DisplayName','Velocity'); end
            legend('show'); xlabel('Time [s]');
        end
    catch
        % ignore
    end
end

% Task 6: Truth vs Fused overlays (compute if missing)
truth_ok = false;
truth_pos_ned_i = []; truth_vel_ned_i = [];
if isfield(S,'truth_pos_ned_i') && ~isempty(S.truth_pos_ned_i)
    truth_pos_ned_i = S.truth_pos_ned_i; truth_ok = true;
    if isfield(S,'truth_vel_ned_i'), truth_vel_ned_i = S.truth_vel_ned_i; end
else
    % Try to construct truth series from MAT, else from DATA/Truth file
    try
        [truth_pos_ned_i, truth_vel_ned_i] = local_build_truth_ned(S, t);
        if ~isempty(truth_pos_ned_i), truth_ok = true; end
    catch ME
        warning('Task 6 truth overlay unavailable: %s', ME.message);
    end
end
if truth_ok
    figure('Name','Task 6 — Truth vs Fused (NED)','Color','w');
    for i=1:3
        subplot(3,2,2*i-1); hold on; grid on; title(['Pos ' labels{i}]);
        plot(t, truth_pos_ned_i(:,i), 'k-', 'DisplayName','Truth');
        if ~isempty(pos), plot(t, pos(:,i), 'b--', 'DisplayName','Fused'); end
        legend('show'); xlabel('Time [s]'); ylabel('m');
        subplot(3,2,2*i); hold on; grid on; title(['Vel ' labels{i}]);
        if ~isempty(truth_vel_ned_i)
            plot(t, truth_vel_ned_i(:,i), 'k-', 'DisplayName','Truth');
        end
        if ~isempty(vel), plot(t, vel(:,i), 'b--', 'DisplayName','Fused'); end
        legend('show'); xlabel('Time [s]'); ylabel('m/s');
    end
end

% Attitude angles (deg)
if ~isempty(eul_deg)
    figure('Name','Attitude over Time (deg)','Color','w');
    subplot(3,1,1); plot(t, eul_deg(:,1)); grid on; ylabel('Roll [deg]');
    subplot(3,1,2); plot(t, eul_deg(:,2)); grid on; ylabel('Pitch [deg]');
    subplot(3,1,3); plot(t, eul_deg(:,3)); grid on; ylabel('Yaw [deg]'); xlabel('Time [s]');
end

% Optional: ECEF/Body plots if present
dirs = {'X','Y','Z'};
pos_ecef_any = [];
gnss_ecef_any = [];
if isfield(S,'pos_ecef') && ~isempty(S.pos_ecef), pos_ecef_any = S.pos_ecef; end
if isempty(pos_ecef_any) && isfield(S,'pos_ecef_m') && ~isempty(S.pos_ecef_m), pos_ecef_any = S.pos_ecef_m; end
if isfield(S,'gnss_pos_ecef') && ~isempty(S.gnss_pos_ecef), gnss_ecef_any = S.gnss_pos_ecef; end
if ~isempty(pos_ecef_any)
    figure('Name','Task 4 — ECEF Position','Color','w');
    for i=1:3
        subplot(3,1,i); hold on; grid on; title(['r' dirs{i} ' ECEF']);
        plot(t, pos_ecef_any(:,i), 'b-', 'DisplayName','Fused');
        if ~isempty(gnss_ecef_any)
            plot(tg, gnss_ecef_any(:,i), 'k:', 'DisplayName','GNSS');
        end
        legend('show');
    end
end

% Optionally save all open figures to .fig (+ .png snapshots) for batch use
if ~isempty(save_dir)
    if ~exist(save_dir, 'dir'); mkdir(save_dir); end
    figs = findobj('Type','figure');
    % Derive a tag prefix (optional)
    if ~isempty(tag)
        prefix = tag;
    else
        prefix = basefile;
    end
    for k = 1:numel(figs)
        f = figs(k);
        nm = get(f,'Name'); if isempty(nm), nm = sprintf('figure_%d', get(f,'Number')); end
        nm = regexprep(nm, '[^\w\-]+', '_');
        fig_path = fullfile(save_dir, sprintf('%s_%s.fig', prefix, nm));
        try
            savefig(f, fig_path);
        catch
            warning('Failed to save FIG: %s', fig_path);
        end
        % Also write a PNG snapshot
        try
            png_path = fullfile(save_dir, sprintf('%s_%s.png', prefix, nm));
            set(f, 'PaperPositionMode','auto');
            print(f, png_path, '-dpng', '-r200');
        catch
            % ignore
        end
    end
    fprintf('Saved %d figures under %s\n', numel(figs), save_dir);
end

% ---------- Summary report ----------
msgs = {};
have_tasks = exist('T','var')==1;
msgs{end+1} = sprintf('Task 1 summary: %s', tern(have_tasks && isfield(T,'task1'), 'OK', 'SKIP (no <tag>_tasks.mat or task1 missing)'));
msgs{end+1} = sprintf('Task 2 summary: %s', tern(have_tasks && isfield(T,'task2'), 'OK', 'SKIP (no <tag>_tasks.mat or task2 missing)'));
msgs{end+1} = sprintf('Task 3 summary: %s', tern(have_tasks && isfield(T,'task3'), 'OK', 'SKIP (no <tag>_tasks.mat or task3 missing)'));
msgs{end+1} = sprintf('Task 4 — NED States (pos/vel/acc): %s', tern(~isempty(pos), 'OK', 'SKIP (no pos_ned/pos_ned_m/fused_pos)'));
msgs{end+1} = sprintf('GNSS overlays (interp): %s', tern(~isempty(gpos_i) || ~isempty(gvel_i), 'OK', 'SKIP (no gnss_pos_ned_interp/gnss_vel_ned_interp and no CSV)'));
msgs{end+1} = sprintf('GNSS overlays (raw): %s', tern(~isempty(gpos) || ~isempty(gvel), 'OK', 'SKIP (no gnss_pos_ned/gnss_vel_ned and no CSV)'));
msgs{end+1} = sprintf('Task 5 — Innovations: %s', tern(~isempty(innov_pos) || (~isempty(gpos_i) && ~isempty(pos)), 'OK (KF or approx)', 'SKIP (innov_pos missing and GNSS interp unavailable)'));
msgs{end+1} = sprintf('Task 5 — Residuals: %s', tern((~isempty(res_pos) && ~isempty(time_res)) || (~isempty(gpos_i) && ~isempty(pos)), 'OK (KF or GNSS-based)', 'SKIP (residuals missing and GNSS interp unavailable)'));
msgs{end+1} = sprintf('Task 6 — Truth overlay: %s', tern(truth_ok, 'OK', 'SKIP (truth_pos_ned_i missing)'));
msgs{end+1} = sprintf('Attitude (deg): %s', tern(~isempty(eul_deg), 'OK', 'SKIP (euler_deg and quaternions missing)'));
msgs{end+1} = sprintf('Task 4 — ECEF Position: %s', tern(~isempty(pos_ecef_any), tern(~isempty(gnss_ecef_any),'OK','OK (fused only, no GNSS)'), 'SKIP (no pos_ecef/_m)'));

fprintf('--- MATLAB plot summary for %s ---\n', basefile);
for i=1:numel(msgs), fprintf('%2d. %s\n', i, msgs{i}); end
fprintf('Note: Additional Python-only plots (mixed frames, method grids, full Task 7) are not reproduced here.\n');

% Task 7.5 — Diff Truth−Fused over time (NED/ECEF), computed natively if truth_ok
if truth_ok
    try
        % NED diffs
        dpos = pos - truth_pos_ned_i;
        dvel = [];
        if ~isempty(truth_vel_ned_i) && ~isempty(vel), dvel = vel - truth_vel_ned_i; end
        figure('Name','Task 7.5 — Diff Truth−Fused over time (NED)','Color','w');
        for i=1:3
            subplot(3,1,i); hold on; grid on; title(['\Delta ' labels{i} ' (Truth−Fused)']);
            plot(t, dpos(:,i), 'b-', 'DisplayName','Pos');
            if ~isempty(dvel), plot(t, dvel(:,i), 'r--', 'DisplayName','Vel'); end
            legend('show'); xlabel('Time [s]'); ylabel('m or m/s');
        end
        % ECEF diffs
        C = local_C_ecef_to_ned(S.ref_lat_rad(1), S.ref_lon_rad(1));
        Cn2e = C'; r0 = S.ref_r0_m(:)';
        pos_ecef_fused = [];
        if isfield(S,'pos_ecef') && ~isempty(S.pos_ecef)
            pos_ecef_fused = S.pos_ecef;
        else
            pos_ecef_fused = (Cn2e * pos.').'+ r0;
        end
        vel_ecef_fused = [];
        if isfield(S,'vel_ecef') && ~isempty(S.vel_ecef)
            vel_ecef_fused = S.vel_ecef;
        elseif ~isempty(vel)
            vel_ecef_fused = (Cn2e * vel.').';
        end
        % Truth ECEF from source (interpolate to IMU time)
        [t_truth, pos_ecef_truth, vel_ecef_truth] = local_truth_ecef_series(S);
        if ~isempty(pos_ecef_truth)
            pos_ecef_i = interp1(t_truth, pos_ecef_truth, t, 'linear', 'extrap');
            figure('Name','Task 7.5 — Diff Truth−Fused over time (ECEF)','Color','w');
            dirs_e = {'X','Y','Z'};
            for i=1:3
                subplot(3,1,i); hold on; grid on; title(['\Delta ' dirs_e{i} ' (Truth−Fused)']);
                plot(t, pos_ecef_i(:,i) - pos_ecef_fused(:,i), 'b-', 'DisplayName','Pos');
                if ~isempty(vel_ecef_fused) && ~isempty(vel_ecef_truth)
                    vel_ecef_i = interp1(t_truth, vel_ecef_truth, t, 'linear', 'extrap');
                    plot(t, vel_ecef_i(:,i) - vel_ecef_fused(:,i), 'r--', 'DisplayName','Vel');
                end
                legend('show'); xlabel('Time [s]'); ylabel('m or m/s');
            end
        end
    catch ME
        warning('Task 7.5 native diffs unavailable: %s', ME.message);
    end

    % --- Task 7.6 — Overlays in NED/ECEF/Body (interactive) ---
    try
        % Ensure we have NED fused/truth
        pos_ned_f = pos; vel_ned_f = vel;
        pos_ned_t = truth_pos_ned_i; vel_ned_t = truth_vel_ned_i;
        % Trim to common time length and normalise time to start at 0
        [tN, pos_ned_t, pos_ned_f, vel_ned_t, vel_ned_f] = local_trim_all(t, pos_ned_t, pos_ned_f, vel_ned_t, vel_ned_f);
        if ~isempty(tN), tN = tN - tN(1); end
        % NED overlay (match Python layout/style: 2x3 grid, Fused solid, Truth dashed,
        % robust symmetric y-limits at 99.5th percentile, optional decimation)
        fN = figure('Name', sprintf('%s_task7_6_overlay_NED', tag), 'Color','w');
        nN = numel(tN);
        stride = max(1, ceil(nN/200000));
        t_plot = tN(1:stride:end);
        p_est = pos_ned_f(1:stride:end, :);
        p_tru = pos_ned_t(1:stride:end, :);
        v_est = [];
        v_tru = [];
        if ~isempty(vel_ned_f), v_est = vel_ned_f(1:stride:end, :); end
        if ~isempty(vel_ned_t), v_tru = vel_ned_t(1:stride:end, :); end
        % Position row
        for i=1:3
            ax = subplot(2,3,i); hold(ax,'on'); grid(ax,'on'); title(ax, labels{i});
            plot(ax, t_plot, p_est(:,i), '-', 'DisplayName','Fused');
            plot(ax, t_plot, p_tru(:,i), '--', 'DisplayName','Truth');
            ylabel(ax, 'Position [m]');
        end
        % Velocity row
        for i=1:3
            ax = subplot(2,3,3+i); hold(ax,'on'); grid(ax,'on');
            if ~isempty(v_est), plot(ax, t_plot, v_est(:,i), '-', 'DisplayName','Fused'); end
            if ~isempty(v_tru), plot(ax, t_plot, v_tru(:,i), '--', 'DisplayName','Truth'); end
            xlabel(ax, 'Time [s]'); ylabel(ax, 'Velocity [m/s]');
        end
        % Harmonised symmetric limits across columns
        try
            lim_p = prctile(abs([p_est(:); p_tru(:)]), 99.5);
            if isfinite(lim_p) && lim_p>0
                for i=1:3, ylim(subplot(2,3,i), [-lim_p lim_p]); end
            end
            if ~isempty(v_est) || ~isempty(v_tru)
                v_all = [];
                if ~isempty(v_est), v_all = [v_all; v_est(:)]; end
                if ~isempty(v_tru), v_all = [v_all; v_tru(:)]; end
                lim_v = prctile(abs(v_all), 99.5);
                if isfinite(lim_v) && lim_v>0
                    for i=1:3, ylim(subplot(2,3,3+i), [-lim_v lim_v]); end
                end
            end
        catch, end
        % Legend and title
        try
            [h,l] = legend(subplot(2,3,1)); %#ok<ASGLU>
            legend(subplot(2,3,1),'show','Location','northoutside','Orientation','horizontal');
        catch, end
        try, sgtitle(sprintf('Task 7.6 – Truth vs Fused (NED Frame)')); catch, end
        % Persist overlay data/figure as .mat/.fig next to Python results
        try
            thisdir = fileparts(mfilename('fullpath'));
            out_dir = fullfile(thisdir, '..', 'results');
            if ~exist(out_dir,'dir'), mkdir(out_dir); end
            base = fullfile(out_dir, sprintf('%s_task7_6_overlay_NED', tag));
            data = struct('time', tN, 'pos_truth', pos_ned_t, 'pos_fused', pos_ned_f, ...
                          'vel_truth', vel_ned_t, 'vel_fused', vel_ned_f); %#ok<NASGU>
            save([base '.mat'], 'data');
            try, savefig(fN, [base '.fig']); catch, end
        catch ME
            warning('Could not save Task 7.6 NED overlay MAT/FIG: %s', ME.message);
        end

        % ECEF overlay (match Python): rotate NED -> ECEF without r0 translation
        C = local_C_ecef_to_ned(S.ref_lat_rad(1), S.ref_lon_rad(1)); Cn2e = C';
        pos_ecef_f = (Cn2e * pos_ned_f.').';
        pos_ecef_ti = (Cn2e * pos_ned_t.').';
        vel_ecef_f = []; vel_ecef_ti = [];
        if ~isempty(vel_ned_f), vel_ecef_f = (Cn2e * vel_ned_f.').'; end
        if ~isempty(vel_ned_t), vel_ecef_ti = (Cn2e * vel_ned_t.').'; end
        dirs_e = {'X','Y','Z'};
        [tE, pos_ecef_ti, pos_ecef_f, vel_ecef_ti, vel_ecef_f] = local_trim_all(tN, pos_ecef_ti, pos_ecef_f, vel_ecef_ti, vel_ecef_f);
        if ~isempty(tE), tE = tE - tE(1); end
        fE = figure('Name', sprintf('%s_task7_6_overlay_ECEF', tag), 'Color','w');
        nE = numel(tE);
        stride = max(1, ceil(nE/200000));
        t_plot = tE(1:stride:end);
        p_est = pos_ecef_f(1:stride:end, :);
        p_tru = pos_ecef_ti(1:stride:end, :);
            v_est = []; v_tru = [];
            if ~isempty(vel_ecef_f),  v_est = vel_ecef_f(1:stride:end, :); end
            if ~isempty(vel_ecef_ti), v_tru = vel_ecef_ti(1:stride:end, :); end
            for i=1:3
                ax = subplot(2,3,i); hold(ax,'on'); grid(ax,'on'); title(ax, dirs_e{i});
                plot(ax, t_plot, p_est(:,i), '-', 'DisplayName','Fused');
                plot(ax, t_plot, p_tru(:,i), '--', 'DisplayName','Truth');
                ylabel(ax, 'Position [m]');
            end
            for i=1:3
                ax = subplot(2,3,3+i); hold(ax,'on'); grid(ax,'on');
                if ~isempty(v_est), plot(ax, t_plot, v_est(:,i), '-', 'DisplayName','Fused'); end
                if ~isempty(v_tru), plot(ax, t_plot, v_tru(:,i), '--', 'DisplayName','Truth'); end
                xlabel(ax, 'Time [s]'); ylabel(ax, 'Velocity [m/s]');
            end
            try
                lim_p = prctile(abs([p_est(:); p_tru(:)]), 99.5);
                if isfinite(lim_p) && lim_p>0
                    for i=1:3, ylim(subplot(2,3,i), [-lim_p lim_p]); end
                end
                if ~isempty(v_est) || ~isempty(v_tru)
                    v_all = [];
                    if ~isempty(v_est), v_all = [v_all; v_est(:)]; end
                    if ~isempty(v_tru), v_all = [v_all; v_tru(:)]; end
                    lim_v = prctile(abs(v_all), 99.5);
                    if isfinite(lim_v) && lim_v>0
                        for i=1:3, ylim(subplot(2,3,3+i), [-lim_v lim_v]); end
                    end
                end
            catch, end
            try
                legend(subplot(2,3,1),'show','Location','northoutside','Orientation','horizontal');
            catch, end
            try, sgtitle(sprintf('Task 7.6 – Truth vs Fused (ECEF Frame)')); catch, end
            % Persist overlay data/figure as .mat/.fig next to Python results
            try
                thisdir = fileparts(mfilename('fullpath'));
                out_dir = fullfile(thisdir, '..', 'results');
                if ~exist(out_dir,'dir'), mkdir(out_dir); end
                base = fullfile(out_dir, sprintf('%s_task7_6_overlay_ECEF', tag));
                data = struct('time', tE, 'pos_truth', pos_ecef_ti, 'pos_fused', pos_ecef_f, ...
                              'vel_truth', vel_ecef_ti, 'vel_fused', vel_ecef_f); %#ok<NASGU>
                save([base '.mat'], 'data');
                try, savefig(fE, [base '.fig']); catch, end
            catch ME
                warning('Could not save Task 7.6 ECEF overlay MAT/FIG: %s', ME.message);
            end
        end

        % Body overlay (3x2) using time-varying quaternion to match Python
        Q = [];
        if isfield(S,'attitude_q') && ~isempty(S.attitude_q), Q = S.attitude_q; end
        if isempty(Q) && isfield(S,'att_quat') && ~isempty(S.att_quat), Q = S.att_quat; end
        if isempty(Q) && isfield(S,'quat_log') && ~isempty(S.quat_log), Q = S.quat_log; end
        R_bn = local_quat_series_to_rotmats(Q);  % body->NED, per-sample
        % Trim to common length
        Nmin = min([size(R_bn,3), size(pos_ned_f,1), size(pos_ned_t,1)]);
        R_bn = R_bn(:,:,1:Nmin);
        pos_ned_f = pos_ned_f(1:Nmin,:); pos_ned_t = pos_ned_t(1:Nmin,:);
        if ~isempty(vel_ned_f), vel_ned_f = vel_ned_f(1:Nmin,:); end
        if ~isempty(vel_ned_t), vel_ned_t = vel_ned_t(1:Nmin,:); end
        tB = tN(1:Nmin);
        % Rotate NED -> Body using inverse rotation each sample
        pos_body_f = zeros(Nmin,3); pos_body_t = zeros(Nmin,3);
        vel_body_f = []; vel_body_t = [];
        for k = 1:Nmin
            Cnb = R_bn(:,:,k);  % body->NED
            Cbn = Cnb';         % NED->body
            pos_body_f(k,:) = (Cbn * pos_ned_f(k,:).').';
            pos_body_t(k,:) = (Cbn * pos_ned_t(k,:).').';
            if ~isempty(vel_ned_f)
                if isempty(vel_body_f), vel_body_f = zeros(Nmin,3); end
                vel_body_f(k,:) = (Cbn * vel_ned_f(k,:).').';
            end
            if ~isempty(vel_ned_t)
                if isempty(vel_body_t), vel_body_t = zeros(Nmin,3); end
                vel_body_t(k,:) = (Cbn * vel_ned_t(k,:).').';
            end
        end
        if ~isempty(tB), tB = tB - tB(1); end
        fB = figure('Name', sprintf('%s_task7_6_overlay_Body', tag), 'Color','w');
        dirs_b = {'X','Y','Z'};
        nB = numel(tB);
        stride = max(1, ceil(nB/200000));
        t_plot = tB(1:stride:end);
        p_est = pos_body_f(1:stride:end, :);
        p_tru = pos_body_t(1:stride:end, :);
        v_est = []; v_tru = [];
        if ~isempty(vel_body_f), v_est = vel_body_f(1:stride:end, :); end
        if ~isempty(vel_body_t), v_tru = vel_body_t(1:stride:end, :); end
        for i=1:3
            ax = subplot(2,3,i); hold(ax,'on'); grid(ax,'on'); title(ax, dirs_b{i});
            plot(ax, t_plot, p_est(:,i), '-', 'DisplayName','Fused');
            plot(ax, t_plot, p_tru(:,i), '--', 'DisplayName','Truth');
            ylabel(ax, 'Position [m]');
        end
        for i=1:3
            ax = subplot(2,3,3+i); hold(ax,'on'); grid(ax,'on');
            if ~isempty(v_est), plot(ax, t_plot, v_est(:,i), '-', 'DisplayName','Fused'); end
            if ~isempty(v_tru), plot(ax, t_plot, v_tru(:,i), '--', 'DisplayName','Truth'); end
            xlabel(ax, 'Time [s]'); ylabel(ax, 'Velocity [m/s]');
        end
        try
            lim_p = prctile(abs([p_est(:); p_tru(:)]), 99.5);
            if isfinite(lim_p) && lim_p>0
                for i=1:3, ylim(subplot(2,3,i), [-lim_p lim_p]); end
            end
            if ~isempty(v_est) || ~isempty(v_tru)
                v_all = [];
                if ~isempty(v_est), v_all = [v_all; v_est(:)]; end
                if ~isempty(v_tru), v_all = [v_all; v_tru(:)]; end
                lim_v = prctile(abs(v_all), 99.5);
                if isfinite(lim_v) && lim_v>0
                    for i=1:3, ylim(subplot(2,3,3+i), [-lim_v lim_v]); end
                end
            end
        catch, end
        try
            legend(subplot(2,3,1),'show','Location','northoutside','Orientation','horizontal');
        catch, end
        try, sgtitle(sprintf('Task 7.6 – Truth vs Fused (Body Frame)')); catch, end
        % Persist overlay data/figure as .mat/.fig next to Python results
        try
            thisdir = fileparts(mfilename('fullpath'));
            out_dir = fullfile(thisdir, '..', 'results');
            if ~exist(out_dir,'dir'), mkdir(out_dir); end
            base = fullfile(out_dir, sprintf('%s_task7_6_overlay_Body', tag));
            data = struct('time', tB, 'pos_truth', pos_body_t, 'pos_fused', pos_body_f, ...
                          'vel_truth', vel_body_t, 'vel_fused', vel_body_f); %#ok<NASGU>
            save([base '.mat'], 'data');
            try, savefig(fB, [base '.fig']); catch, end
        catch ME
            warning('Could not save Task 7.6 Body overlay MAT/FIG: %s', ME.message);
        end

        % Body-frame diffs (Task 7.5) — Δpos/Δvel in body frame
        figure('Name', sprintf('%s_task7_5_diff_truth_fused_over_time_Body', tag), 'Color','w');
        for i=1:3
            subplot(3,1,i); hold on; grid on; title(sprintf('%s (Truth-Fused) in Body', [char(916) dirs_b{i}]));
            plot(tB, pos_body_t(:,i) - pos_body_f(:,i), 'b-', 'DisplayName','Pos');
            if ~isempty(vel_body_t) && ~isempty(vel_body_f)
                plot(tB, vel_body_t(:,i) - vel_body_f(:,i), 'r--', 'DisplayName','Vel');
            end
            legend('show'); xlabel('Time [s]'); ylabel('m or m/s');
        end

    catch ME
        warning('Task 7.6 overlays/body-diffs unavailable: %s', ME.message);
    end
end

% Try to load and display existing Task 7 figures for this tag (native-only);
% then recreate Task 7 plots interactively from saved MAT bundles if present.
thisdir = fileparts(mfilename('fullpath'));
py_results = fullfile(thisdir, '..', 'results');
fig_pat = fullfile(py_results, sprintf('%s_Task7*.fig', tag));
task7_figs = dir(fig_pat);
if ~isempty(task7_figs)
    fprintf('Opening Task 7 native .fig files only (interactive): %d found\n', numel(task7_figs));
    for k = 1:numel(task7_figs)
        fpath = fullfile(task7_figs(k).folder, task7_figs(k).name);
        try
            openfig(fpath, 'new', 'visible');
        catch ME
            warning('Skipping non-native FIG (not interactive): %s (%s)', task7_figs(k).name, ME.message);
        end
    end
else
    fprintf('No pre-saved Task 7 .fig files found for tag %s in %s\n', tag, py_results);
end

% Additionally, regenerate Task 7 plots interactively from saved MAT bundles
mat_pat = fullfile(py_results, sprintf('%s_Task7*.mat', tag));
task7_mats = dir(mat_pat);
if ~isempty(task7_mats)
    fprintf('Recreating Task 7 plots from %d saved MAT bundle(s)\n', numel(task7_mats));
    for k = 1:numel(task7_mats)
        try
            local_replot_from_saved_mat(fullfile(task7_mats(k).folder, task7_mats(k).name));
        catch ME
            warning('Failed to recreate Task 7 from MAT: %s (%s)', task7_mats(k).name, ME.message);
        end
    end
end

disp('MATLAB plots generated from saved MAT bundle.');
end  % <-- end of main function plot_all_from_mat

%% ---------- Local helpers ----------
function v = local_getf(S, name, def)
if isfield(S, name)
    v = S.(name);
else
    v = def;
end
end

function [tag, basefile] = local_tag_from_path(mat_path, S)
[~, basefile] = fileparts(mat_path);
tag = '';
if isfield(S,'tag') && ~isempty(S.tag)
    try
        if iscell(S.tag), tag = S.tag{1}; else, tag = S.tag; end
    catch
        tag = '';
    end
end
if isempty(tag)
    % Try to parse from filename pattern <tag>_kf_output
    k = strfind(basefile, '_kf_output');
    if ~isempty(k)
        tag = basefile(1:k(1)-1);
    end
end
end

function out = tern(cond, a, b)
if cond, out = a; else, out = b; end
end

function eul_deg = local_quat_to_euler_deg(Q)
% Convert Nx4 quaternions to Euler XYZ (roll,pitch,yaw) in degrees.
% Tries both [w x y z] and [x y z w] conventions and picks the one with
% fewer NaNs after asin (heuristic for robustness).
Q = double(Q);
if size(Q,2) ~= 4, eul_deg = []; return; end
% Candidate 1: [w x y z]
qw=Q(:,1); qx=Q(:,2); qy=Q(:,3); qz=Q(:,4);
roll1  = atan2(2*(qw.*qx + qy.*qz), 1 - 2*(qx.^2 + qy.^2));
sp1    = 2*(qw.*qy - qz.*qx); sp1 = max(min(sp1,1),-1); % clamp
pitch1 = asin(sp1);
yaw1   = atan2(2*(qw.*qz + qx.*qy), 1 - 2*(qy.^2 + qz.^2));
bad1   = sum(~isfinite([roll1 pitch1 yaw1]),2);
% Candidate 2: [x y z w]
qx=Q(:,1); qy=Q(:,2); qz=Q(:,3); qw=Q(:,4);
roll2  = atan2(2*(qw.*qx + qy.*qz), 1 - 2*(qx.^2 + qy.^2));
sp2    = 2*(qw.*qy - qz.*qx); sp2 = max(min(sp2,1),-1);
pitch2 = asin(sp2);
yaw2   = atan2(2*(qw.*qz + qx.*qy), 1 - 2*(qy.^2 + qz.^2));
bad2   = sum(~isfinite([roll2 pitch2 yaw2]),2);
% Pick best
if sum(bad1) <= sum(bad2)
    eul = [roll1 pitch1 yaw1];
else
    eul = [roll2 pitch2 yaw2];
end
eul_deg = eul * (180/pi);
end

function R = local_quat_to_rotmat(q, conv)
% Convert a 1x4 quaternion to a 3x3 rotation matrix.
% conv='wxyz' means q=[w x y z] (scalar-first). conv='xyzw' means q=[x y z w].
q = double(q(:)');
if numel(q) ~= 4, R = []; return; end
switch lower(conv)
    case 'wxyz', w=q(1); x=q(2); y=q(3); z=q(4);
    case 'xyzw', x=q(1); y=q(2); z=q(3); w=q(4);
    otherwise, R = []; return;
end

function Rbn = local_quat_series_to_rotmats(Q)
% Convert Nx4 quaternion series to 3x3xN rotation matrices (body->NED).
% Tries scalar-first [w x y z] then vector-first [x y z w].
Rbn = [];
if isempty(Q) || size(Q,2) ~= 4
    return
end
Q = double(Q);
N = size(Q,1);
% candidate 1: wxyz
R1 = zeros(3,3,N);
bad1 = 0;
for i=1:N
    Ri = local_quat_to_rotmat(Q(i,:), 'wxyz');
    if isempty(Ri) || any(~isfinite(Ri),'all'), bad1 = bad1 + 1; Ri = eye(3); end
    R1(:,:,i) = Ri;
end
% candidate 2: xyzw
R2 = zeros(3,3,N);
bad2 = 0;
for i=1:N
    Ri = local_quat_to_rotmat(Q(i,:), 'xyzw');
    if isempty(Ri) || any(~isfinite(Ri),'all'), bad2 = bad2 + 1; Ri = eye(3); end
    R2(:,:,i) = Ri;
end
if bad1 <= bad2
    Rbn = R1;
else
    Rbn = R2;
end
end
% Normalize
n = sqrt(w*w + x*x + y*y + z*z); if n==0, R=[]; return; end
w=w/n; x=x/n; y=y/n; z=z/n;
R = [1-2*(y*y+z*z), 2*(x*y - w*z), 2*(x*z + w*y);
    2*(x*y + w*z), 1-2*(x*x+z*z), 2*(y*z - w*x);
    2*(x*z - w*y), 2*(y*z + w*x), 1-2*(x*x+y*y)];
end

function [pos_ned_i, vel_ned_i] = local_build_truth_ned(S, t)
pos_ned_i = []; vel_ned_i = [];
% Use truth from MAT if available
if isfield(S,'truth_time') && isfield(S,'truth_pos_ecef') && ~isempty(S.truth_pos_ecef)
    t_truth = S.truth_time(:);
    pos_ecef = S.truth_pos_ecef; vel_ecef = [];
    if isfield(S,'truth_vel_ecef'), vel_ecef = S.truth_vel_ecef; end
else
    % Fallback: scan DATA/Truth for STATE_*.txt and pick the first
    [t_truth, pos_ecef, vel_ecef] = local_load_truth_file();
end
if isempty(pos_ecef), return; end
C = local_C_ecef_to_ned(S.ref_lat_rad(1), S.ref_lon_rad(1));
r0 = S.ref_r0_m(:)';
pos_ned = (C * (pos_ecef - r0)').';
pos_ned_i = interp1(t_truth, pos_ned, t, 'linear', 'extrap');
if ~isempty(vel_ecef)
    vel_ned = (C * vel_ecef').';
    vel_ned_i = interp1(t_truth, vel_ned, t, 'linear', 'extrap');
end
end

function [t_truth, pos_ecef, vel_ecef] = local_truth_ecef_series(S)
t_truth = []; pos_ecef = []; vel_ecef = [];
if isfield(S,'truth_time') && ~isempty(S.truth_time)
    t_truth = S.truth_time(:);
    if isfield(S,'truth_pos_ecef'), pos_ecef = S.truth_pos_ecef; end
    if isfield(S,'truth_vel_ecef'), vel_ecef = S.truth_vel_ecef; end
    return
end
% else load from file
[t_truth, pos_ecef, vel_ecef] = local_load_truth_file();
end

function [t2, varargout] = local_trim_all(t, varargin)
% Trim all arrays to the minimum common length with t.
minLen = length(t);
lens = zeros(1, numel(varargin));
for i=1:numel(varargin)
    Ai = varargin{i};
    if ~isempty(Ai)
        lens(i) = size(Ai,1);
        if lens(i) > 0
            minLen = min(minLen, lens(i));
        end
    end
end
if minLen < 1
    t2 = t; varargout = varargin; return
end
t2 = t(1:minLen);
varargout = cell(1, numel(varargin));
for i=1:numel(varargin)
    Ai = varargin{i};
    if isempty(Ai)
        varargout{i} = Ai;
    else
        varargout{i} = Ai(1:minLen, :);
    end
end
end

function [t_truth, pos_ecef, vel_ecef] = local_load_truth_file()
t_truth = []; pos_ecef = []; vel_ecef = [];
thisdir = fileparts(mfilename('fullpath'));
repo_root = fullfile(thisdir, '..', '..');
d = dir(fullfile(repo_root, 'DATA', 'Truth', 'STATE_*.txt'));
if isempty(d), return; end
f = fullfile(d(1).folder, d(1).name);
try
    raw = readmatrix(f);
    % Heuristic: time column is the first with monotonic increase
    t_truth = raw(:,1);
    % Expect ECEF columns 2:4 and 5:7 or 2:4 pos and 5:7 vel
    pos_ecef = raw(:,2:4);
    vel_ecef = raw(:,5:7);
catch
    % ignore
end
end
function [tg, gpos_ned, gvel_ned, gpos_i, gvel_i, gacc_i] = local_load_gnss_derived(tag, t_imu, S)
% Derive GNSS NED overlays from CSV using ref lat/lon/r0 from the MAT.
% Returns raw NED (GNSS timestamps), IMU-aligned NED via interp1, and GNSS accel.
tg = []; gpos_ned = []; gvel_ned = []; gpos_i = []; gvel_i = []; gacc_i = [];
if ~isfield(S,'ref_lat_rad') || ~isfield(S,'ref_lon_rad') || ~isfield(S,'ref_r0_m')
    error('ref_lat_rad/ref_lon_rad/ref_r0_m not found in MAT');
end
% Resolve GNSS dataset ID from tag pattern IMU_<ID>_GNSS_<ID>_METHOD
toks = regexp(tag, 'IMU_(?<imid>[^_]+)_GNSS_(?<gnid>[^_]+)_', 'names');
if isempty(toks) || ~isfield(toks,'gnid')
    error('Cannot parse GNSS ID from tag "%s"', tag);
end
thisdir = fileparts(mfilename('fullpath'));
repo_root = fullfile(thisdir, '..', '..');
gnss_csv = fullfile(repo_root, 'DATA', 'GNSS', sprintf('GNSS_%s.csv', toks.gnid));
if exist(gnss_csv,'file') ~= 2
    error('GNSS CSV not found: %s', gnss_csv);
end
T = readtable(gnss_csv);
% Expect headers like X_ECEF_m, Y_ECEF_m, Z_ECEF_m, VX_ECEF_mps, VY_ECEF_mps, VZ_ECEF_mps, Posix_Time
req = {'X_ECEF_m','Y_ECEF_m','Z_ECEF_m','VX_ECEF_mps','VY_ECEF_mps','VZ_ECEF_mps','Posix_Time'};
for i=1:numel(req)
    if ~ismember(req{i}, T.Properties.VariableNames)
        error('Missing column in GNSS CSV: %s', req{i});
    end
end
pos_e = [T.X_ECEF_m, T.Y_ECEF_m, T.Z_ECEF_m];
vel_e = [T.VX_ECEF_mps, T.VY_ECEF_mps, T.VZ_ECEF_mps];
tg = T.Posix_Time - T.Posix_Time(1);
% Convert to NED using ref from S
C = local_C_ecef_to_ned(S.ref_lat_rad(1), S.ref_lon_rad(1));
r0 = S.ref_r0_m(:)';
gpos_ned = (C * (pos_e - r0)').';
gvel_ned = (C * vel_e').';
% Interpolate to IMU time base
gpos_i = interp1(tg, gpos_ned, t_imu, 'linear', 'extrap');
gvel_i = interp1(tg, gvel_ned, t_imu, 'linear', 'extrap');
% Acceleration in NED via finite difference, then interpolate to IMU time
dtg = [tg(1); diff(tg)]; dtg(dtg==0) = NaN;  % avoid /0 at first sample
acc_e = [zeros(1,3); diff(vel_e)]./dtg;
acc_e(~isfinite(acc_e)) = 0;
acc_ned = (C * acc_e').';
gacc_i = interp1(tg, acc_ned, t_imu, 'linear', 'extrap');
end

function C = local_C_ecef_to_ned(lat, lon)
sL = sin(lat); cL = cos(lat); sB = sin(lon); cB = cos(lon);
C = [-sL*cB, -sL*sB,  cL;
    -sB,     cB,    0;
    -cL*cB, -cL*sB, -sL];
end

function local_replot_from_saved_mat(mat_file)
% Recreate plots saved via utils_legacy.save_plot_mat into <...>.mat bundles.
% Expects keys like ax1_line1_x, ax1_line1_y, ax1_title, ax1_xlabel, ax1_ylabel, etc.
try
    D = load(mat_file);
catch ME
    warning('Could not load MAT: %s (%s)', mat_file, ME.message);
    return
end
fn = fieldnames(D);
ax_ids = [];
for i=1:numel(fn)
    tok = regexp(fn{i}, '^ax(\d+)_', 'tokens', 'once');
    if ~isempty(tok)
        ax_ids(end+1) = str2double(tok{1}); %#ok<AGROW>
    end
end
ax_ids = unique(ax_ids);
if isempty(ax_ids)
    % nothing recognizable
    return
end
[~, base] = fileparts(mat_file);
figure('Name', base, 'Color','w');
n = numel(ax_ids);
for idx = 1:n
    ai = ax_ids(idx);
    subplot(n,1,idx); hold on; grid on;
    % find all lines for this axis
    li = 1;
    while true
        xk = sprintf('ax%d_line%d_x', ai, li);
        yk = sprintf('ax%d_line%d_y', ai, li);
        if ~isfield(D, xk) || ~isfield(D, yk), break; end
        x = D.(xk); y = D.(yk);
        if isvector(x) && isvector(y)
            plot(x(:), y(:));
        end
        li = li + 1;
    end
    % labels
    tk = sprintf('ax%d_title', ai);
    xlk = sprintf('ax%d_xlabel', ai);
    ylk = sprintf('ax%d_ylabel', ai);
    if isfield(D, tk), title(string(D.(tk))); end
    if isfield(D, xlk), xlabel(string(D.(xlk))); end
    if isfield(D, ylk), ylabel(string(D.(ylk))); end
end
end
